// Copyright 2025 Savas Parastatidis
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using System.Threading;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace Cvoya.Graph.Model.Neo4j.Serialization.CodeGen;

[Generator]
public class EntitySerializerGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var entityTypes = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: IsTargetType,
                transform: GetSemanticTarget)
            .Where(m => m is not null)
            .Collect();

        context.RegisterSourceOutput(entityTypes, GenerateSerializers);
    }

    private static bool IsTargetType(SyntaxNode node, CancellationToken ct)
    {
        return node is TypeDeclarationSyntax typeDecl &&
               typeDecl.BaseList?.Types.Count > 0;
    }

    private static INamedTypeSymbol? GetSemanticTarget(GeneratorSyntaxContext context, CancellationToken ct)
    {
        var typeDecl = (TypeDeclarationSyntax)context.Node;
        var symbol = context.SemanticModel.GetDeclaredSymbol(typeDecl, ct) as INamedTypeSymbol;

        if (symbol is null) return null;

        var interfaces = symbol.AllInterfaces;
        var implementsINode = interfaces.Any(i =>
            i.Name == "INode" &&
            i.ContainingNamespace?.ToString() == "Cvoya.Graph.Model");
        var implementsIRelationship = interfaces.Any(i =>
            i.Name == "IRelationship" &&
            i.ContainingNamespace?.ToString() == "Cvoya.Graph.Model");

        return (implementsINode || implementsIRelationship) ? symbol : null;
    }

    private static void GenerateSerializers(SourceProductionContext context, ImmutableArray<INamedTypeSymbol?> types)
    {
        if (types.IsDefaultOrEmpty) return;

        // Generate individual serializer files
        foreach (var type in types.Where(t => t is not null))
        {
            GenerateSerializerFile(context, type!);
        }

        // Generate registration module
        GenerateRegistrationModule(context, types);
    }

    private static void GenerateSerializerFile(SourceProductionContext context, INamedTypeSymbol type)
    {
        var sb = new StringBuilder();
        var serializerName = $"{type.Name}Serializer";
        var namespaceName = GetNamespaceName(type);

        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Collections.Generic;");
        sb.AppendLine("using Cvoya.Graph.Model.Neo4j.Serialization;");
        sb.AppendLine("using Neo4j.Driver;");
        sb.AppendLine();
        sb.AppendLine($"namespace {namespaceName};");
        sb.AppendLine();
        sb.AppendLine($"internal sealed class {serializerName} : EntitySerializerBase");
        sb.AppendLine("{");
        sb.AppendLine($"    public override Type EntityType => typeof({type.ToDisplayString()});");
        sb.AppendLine();

        GenerateDeserializeMethod(sb, type);
        sb.AppendLine();
        GenerateSerializeMethod(sb, type);

        sb.AppendLine("}");

        context.AddSource($"{serializerName}.g.cs", sb.ToString());
    }

    private static void GenerateDeserializeMethod(StringBuilder sb, INamedTypeSymbol type)
    {
        sb.AppendLine("    public override object Deserialize(global::Neo4j.Driver.IEntity entity)");
        sb.AppendLine("    {");

        // Get all properties
        var properties = type.GetMembers()
            .OfType<IPropertySymbol>()
            .Where(p => !p.IsStatic && p.DeclaredAccessibility == Accessibility.Public)
            .ToList();

        var initOnlyProperties = properties.Where(p => p.SetMethod?.IsInitOnly == true).ToList();
        var regularProperties = properties.Where(p => p.SetMethod != null && !p.SetMethod.IsInitOnly && p.SetMethod.DeclaredAccessibility == Accessibility.Public).ToList();

        // Find the best constructor
        var constructors = type.Constructors
            .Where(c => !c.IsStatic && c.DeclaredAccessibility == Accessibility.Public)
            .OrderBy(c => c.Parameters.Length)
            .ToList();

        var parameterlessConstructor = constructors.FirstOrDefault(c => c.Parameters.Length == 0);

        if (parameterlessConstructor != null && !initOnlyProperties.Any())
        {
            // Simple case - parameterless constructor and no init-only properties
            sb.AppendLine($"        var result = new {type.ToDisplayString()}();");
            GeneratePropertySetters(sb, type, "result", "entity");
        }
        else if (constructors.Any())
        {
            // Find a constructor that can handle our init-only properties
            var bestConstructor = FindBestConstructor(constructors, initOnlyProperties, properties);
            if (bestConstructor != null)
            {
                GenerateConstructorBasedDeserialization(sb, type, bestConstructor, properties);
            }
            else
            {
                // Fall back to first public constructor
                GenerateConstructorBasedDeserialization(sb, type, constructors.First(), properties);
            }
        }
        else
        {
            sb.AppendLine($"        throw new InvalidOperationException(\"No suitable constructor found for type {type.Name}\");");
        }

        sb.AppendLine("        return result;");
        sb.AppendLine("    }");
    }

    private static IMethodSymbol? FindBestConstructor(
    List<IMethodSymbol> constructors,
    List<IPropertySymbol> initOnlyProperties,
    List<IPropertySymbol> allProperties)
    {
        // Try to find a constructor that matches our init-only properties
        foreach (var ctor in constructors)
        {
            var matchedParams = 0;
            foreach (var param in ctor.Parameters)
            {
                var matchingProp = allProperties.FirstOrDefault(p =>
                    string.Equals(p.Name, param.Name, StringComparison.OrdinalIgnoreCase));

                if (matchingProp != null && initOnlyProperties.Contains(matchingProp))
                {
                    matchedParams++;
                }
            }

            // Perfect match - constructor can set all init-only properties
            if (matchedParams == initOnlyProperties.Count)
            {
                return ctor;
            }
        }

        // No perfect match, return constructor with most parameters that match properties
        return constructors
            .OrderByDescending(c => c.Parameters.Count(p =>
                allProperties.Any(prop => string.Equals(prop.Name, p.Name, StringComparison.OrdinalIgnoreCase))))
            .ThenBy(c => c.Parameters.Length)
            .FirstOrDefault();
    }

    private static void GenerateConstructorBasedDeserialization(StringBuilder sb, INamedTypeSymbol type, IMethodSymbol constructor, List<IPropertySymbol> allProperties)
    {
        // Check if any constructor parameters are required (non-nullable)
        var hasRequiredParams = constructor.Parameters.Any(p => p.Type.NullableAnnotation != NullableAnnotation.Annotated);

        if (hasRequiredParams)
        {
            sb.AppendLine("        // Extract required constructor parameters");
        }

        // Extract values for constructor parameters
        foreach (var param in constructor.Parameters)
        {
            var matchingProperty = allProperties.FirstOrDefault(p =>
                string.Equals(p.Name, param.Name, StringComparison.OrdinalIgnoreCase));

            var propertyName = matchingProperty?.Name ?? GetPropertyNameFromParameter(param);
            var paramType = param.Type.ToDisplayString();
            var isNullable = param.Type.NullableAnnotation == NullableAnnotation.Annotated;
            var isReferenceType = param.Type.IsReferenceType;

            if (!isNullable && isReferenceType)
            {
                // For non-nullable reference types, we need to ensure we have a value
                sb.AppendLine($"        string? {param.Name} = null;");
                sb.AppendLine($"        if (TryGetProperty(entity, \"{propertyName}\", out var {param.Name}Value))");
                sb.AppendLine("        {");
                sb.AppendLine($"            {param.Name} = ({paramType}?)ConvertFromNeo4jValue({param.Name}Value, typeof({paramType})) ?? throw new InvalidOperationException(\"Required property '{propertyName}' is missing from entity\");");
                sb.AppendLine("        }");
            }
            else
            {
                // Handle nullable types and value types as before
                if (isNullable)
                {
                    sb.AppendLine($"        {paramType} {param.Name} = default;");
                }
                else
                {
                    sb.AppendLine($"        var {param.Name} = default({paramType})!;");
                }

                sb.AppendLine($"        if (TryGetProperty(entity, \"{propertyName}\", out var {param.Name}Value))");
                sb.AppendLine("        {");

                if (isNullable)
                {
                    sb.AppendLine($"            {param.Name} = {param.Name}Value == null ? null : ({paramType})ConvertFromNeo4jValue({param.Name}Value, typeof({param.Type.WithNullableAnnotation(NullableAnnotation.None).ToDisplayString()}));");
                }
                else
                {
                    sb.AppendLine($"            {param.Name} = ({paramType})ConvertFromNeo4jValue({param.Name}Value, typeof({paramType}))!;");
                }

                sb.AppendLine("        }");
            }
        }

        // Call constructor - use the null-forgiving operator for parameters we've validated
        sb.Append($"        var result = new {type.ToDisplayString()}(");
        var paramList = constructor.Parameters.Select(p =>
        {
            if (p.Type.NullableAnnotation != NullableAnnotation.Annotated && p.Type.IsReferenceType)
                return $"{p.Name}!"; // We've already validated this isn't null
            return p.Name;
        });
        sb.Append(string.Join(", ", paramList));
        sb.AppendLine(");");

        // Set remaining settable properties that weren't in the constructor
        var constructorParamNames = new HashSet<string>(
            constructor.Parameters.Select(p => p.Name.ToLower()),
            StringComparer.OrdinalIgnoreCase);

        var settableProperties = allProperties
            .Where(p => p.SetMethod != null &&
                       !p.SetMethod.IsInitOnly &&
                       p.SetMethod.DeclaredAccessibility == Accessibility.Public &&
                       !constructorParamNames.Contains(p.Name.ToLower()))
            .ToList();

        if (settableProperties.Any())
        {
            GeneratePropertySetters(sb, settableProperties, "result", "entity");
        }
    }

    private static void GenerateSerializeMethod(StringBuilder sb, INamedTypeSymbol type)
    {
        sb.AppendLine($"    public override Dictionary<string, object?> Serialize(object obj)");
        sb.AppendLine("    {");
        sb.AppendLine($"        var entity = ({type.ToDisplayString()})obj;");
        sb.AppendLine("        var properties = new Dictionary<string, object?>();");
        sb.AppendLine();

        var properties = type.GetMembers()
            .OfType<IPropertySymbol>()
            .Where(p => !p.IsStatic && p.DeclaredAccessibility == Accessibility.Public && p.GetMethod != null);

        foreach (var property in properties)
        {
            // Skip properties that shouldn't be serialized - pass the type now
            if (ShouldSkipProperty(property, type))
                continue;

            var propertyName = GetPropertyName(property);

            // Check if it's a simple type we can directly serialize
            if (Cvoya.Graph.Model.Neo4j.Serialization.CodeGen.GraphDataModel.IsSimple(property.Type))
            {
                // Only add null check for reference types and nullable value types
                if (property.Type.IsReferenceType || IsNullableValueType(property.Type))
                {
                    sb.AppendLine($"        if (entity.{property.Name} != null)");
                    sb.AppendLine("        {");
                    sb.AppendLine($"            properties[\"{propertyName}\"] = ConvertToNeo4jValue(entity.{property.Name});");
                    sb.AppendLine("        }");
                }
                else
                {
                    // For non-nullable value types, always add them
                    sb.AppendLine($"        properties[\"{propertyName}\"] = ConvertToNeo4jValue(entity.{property.Name});");
                }
            }
            else if (Cvoya.Graph.Model.Neo4j.Serialization.CodeGen.GraphDataModel.IsCollectionOfSimple(property.Type))
            {
                // Collections are always reference types
                sb.AppendLine($"        if (entity.{property.Name} != null)");
                sb.AppendLine("        {");
                sb.AppendLine($"            properties[\"{propertyName}\"] = ConvertToNeo4jValue(entity.{property.Name});");
                sb.AppendLine("        }");
            }
            // Complex types are skipped - they should be handled as relationships
        }

        sb.AppendLine("        return properties;");
        sb.AppendLine("    }");
    }

    private static bool IsNullableValueType(ITypeSymbol type)
    {
        return type is INamedTypeSymbol namedType &&
               namedType.IsGenericType &&
               namedType.ConstructedFrom.SpecialType == SpecialType.System_Nullable_T;
    }

    private static void GeneratePropertySetters(StringBuilder sb, List<IPropertySymbol> properties, string variableName, string entityVar)
    {
        foreach (var property in properties)
        {
            var propertyName = GetPropertyName(property);
            var typeName = property.Type.ToDisplayString();

            sb.AppendLine($"        if (TryGetProperty({entityVar}, \"{propertyName}\", out var {property.Name.ToLower()}Value))");
            sb.AppendLine("        {");

            if (property.Type.NullableAnnotation == NullableAnnotation.Annotated)
            {
                sb.AppendLine($"            {variableName}.{property.Name} = {property.Name.ToLower()}Value == null ? null : ({typeName})ConvertFromNeo4jValue({property.Name.ToLower()}Value, typeof({property.Type.WithNullableAnnotation(NullableAnnotation.None).ToDisplayString()}));");
            }
            else
            {
                sb.AppendLine($"            {variableName}.{property.Name} = ({typeName})ConvertFromNeo4jValue({property.Name.ToLower()}Value, typeof({typeName}))!;");
            }

            sb.AppendLine("        }");
        }
    }

    private static bool ShouldSkipProperty(IPropertySymbol property, INamedTypeSymbol type)
    {
        // Check if this is a node or relationship
        var isNode = type.AllInterfaces.Any(i =>
            i.Name == "INode" &&
            i.ContainingNamespace?.ToString() == "Cvoya.Graph.Model");

        var isRelationship = type.AllInterfaces.Any(i =>
            i.Name == "IRelationship" &&
            i.ContainingNamespace?.ToString() == "Cvoya.Graph.Model");

        // For relationships, skip StartNodeId and EndNodeId (they're handled by the relationship itself)
        if (isRelationship && (property.Name == "StartNodeId" || property.Name == "EndNodeId"))
            return true;

        // Don't skip Id for nodes - we need it!
        // But for relationships, the Id might be handled differently by Neo4j

        // Skip navigation properties (complex types that aren't simple values)
        if (!Cvoya.Graph.Model.Neo4j.Serialization.CodeGen.GraphDataModel.IsSimple(property.Type) &&
            !Cvoya.Graph.Model.Neo4j.Serialization.CodeGen.GraphDataModel.IsCollectionOfSimple(property.Type))
            return true;

        return false;
    }

    private static void GeneratePropertySetters(StringBuilder sb, INamedTypeSymbol type, string variableName, string entityVar)
    {
        var properties = type.GetMembers()
            .OfType<IPropertySymbol>()
            .Where(p => !p.IsStatic && p.DeclaredAccessibility == Accessibility.Public && !p.IsReadOnly);

        foreach (var property in properties)
        {
            var propertyName = GetPropertyName(property);
            var typeName = property.Type.ToDisplayString();

            sb.AppendLine($"        if (TryGetProperty({entityVar}, \"{propertyName}\", out var {property.Name.ToLower()}Value))");
            sb.AppendLine("        {");

            if (property.Type.NullableAnnotation == NullableAnnotation.Annotated)
            {
                sb.AppendLine($"            {variableName}.{property.Name} = {property.Name.ToLower()}Value == null ? null : ({typeName})ConvertFromNeo4jValue({property.Name.ToLower()}Value, typeof({property.Type.WithNullableAnnotation(NullableAnnotation.None).ToDisplayString()}));");
            }
            else
            {
                sb.AppendLine($"            {variableName}.{property.Name} = ({typeName})ConvertFromNeo4jValue({property.Name.ToLower()}Value, typeof({typeName}))!;");
            }

            sb.AppendLine("        }");
        }
    }

    private static void GenerateRegistrationModule(SourceProductionContext context, ImmutableArray<INamedTypeSymbol?> types)
    {
        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine("using Cvoya.Graph.Model.Neo4j.Serialization;");
        sb.AppendLine();
        sb.AppendLine("internal static class EntitySerializerRegistration");
        sb.AppendLine("{");
        sb.AppendLine("    [System.Runtime.CompilerServices.ModuleInitializer]");
        sb.AppendLine("    public static void Initialize()");
        sb.AppendLine("    {");

        foreach (var type in types.Where(t => t is not null))
        {
            var typeName = type!.ToDisplayString();
            var namespaceName = GetNamespaceName(type);
            var serializerName = $"{type.Name}Serializer";

            sb.AppendLine($"        EntitySerializerRegistry.Register<{typeName}>(new {namespaceName}.{serializerName}());");
        }

        sb.AppendLine("    }");
        sb.AppendLine("}");

        context.AddSource("EntitySerializerRegistration.g.cs", sb.ToString());
    }

    private static string GetPropertyName(IPropertySymbol property)
    {
        var propertyAttribute = property.GetAttributes()
            .FirstOrDefault(a => a.AttributeClass?.Name == "PropertyAttribute");

        if (propertyAttribute?.ConstructorArguments.Length > 0)
        {
            return propertyAttribute.ConstructorArguments[0].Value?.ToString() ?? property.Name;
        }

        return property.Name;
    }

    private static string GetPropertyNameFromParameter(IParameterSymbol parameter)
    {
        return char.ToUpper(parameter.Name[0]) + parameter.Name.Substring(1);
    }

    private static string GetNamespaceName(INamedTypeSymbol type)
    {
        var namespaceName = type.ContainingNamespace?.ToDisplayString();

        if (namespaceName is null || namespaceName == "<global namespace>")
        {
            return "Generated";
        }

        return namespaceName + ".Generated";
    }
}
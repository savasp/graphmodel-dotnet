// Copyright 2025 Savas Parastatidis
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

using System.Collections.Immutable;
using System.Linq;
using System.Text;
using System.Threading;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace Cvoya.Graph.Model.Neo4j.Serialization.CodeGen;

[Generator]
public class EntitySerializerGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var entityTypes = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: IsTargetType,
                transform: GetSemanticTarget)
            .Where(m => m is not null)
            .Collect();

        context.RegisterSourceOutput(entityTypes, GenerateSerializers);
    }

    private static bool IsTargetType(SyntaxNode node, CancellationToken ct)
    {
        return node is TypeDeclarationSyntax typeDecl &&
               typeDecl.BaseList?.Types.Count > 0;
    }

    private static INamedTypeSymbol? GetSemanticTarget(GeneratorSyntaxContext context, CancellationToken ct)
    {
        var typeDecl = (TypeDeclarationSyntax)context.Node;
        var symbol = context.SemanticModel.GetDeclaredSymbol(typeDecl, ct) as INamedTypeSymbol;

        if (symbol is null) return null;

        var interfaces = symbol.AllInterfaces;
        var implementsINode = interfaces.Any(i =>
            i.Name == "INode" &&
            i.ContainingNamespace?.ToString() == "Cvoya.Graph.Model");
        var implementsIRelationship = interfaces.Any(i =>
            i.Name == "IRelationship" &&
            i.ContainingNamespace?.ToString() == "Cvoya.Graph.Model");

        return (implementsINode || implementsIRelationship) ? symbol : null;
    }

    private static void GenerateSerializers(SourceProductionContext context, ImmutableArray<INamedTypeSymbol?> types)
    {
        if (types.IsDefaultOrEmpty) return;

        // Generate individual serializer files
        foreach (var type in types.Where(t => t is not null))
        {
            GenerateSerializerFile(context, type!);
        }

        // Generate registration module
        GenerateRegistrationModule(context, types);
    }

    private static void GenerateSerializerFile(SourceProductionContext context, INamedTypeSymbol type)
    {
        var sb = new StringBuilder();
        var serializerName = $"{type.Name}Serializer";
        var namespaceName = type.ContainingNamespace?.ToDisplayString() ?? "Generated";

        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Collections.Generic;");
        sb.AppendLine("using System.Threading.Tasks;");
        sb.AppendLine("using Cvoya.Graph.Model.Neo4j.Serialization;");
        sb.AppendLine("using Neo4j.Driver;");
        sb.AppendLine();
        sb.AppendLine($"namespace {namespaceName}.Generated;");
        sb.AppendLine();
        sb.AppendLine($"internal sealed class {serializerName} : EntitySerializerBase");
        sb.AppendLine("{");
        sb.AppendLine($"    public override Type EntityType => typeof({type.ToDisplayString()});");
        sb.AppendLine();

        GenerateDeserializeMethod(sb, type);
        sb.AppendLine();
        GenerateSerializeMethod(sb, type);

        sb.AppendLine("}");

        context.AddSource($"{serializerName}.g.cs", sb.ToString());
    }

    private static void GenerateDeserializeMethod(StringBuilder sb, INamedTypeSymbol type)
    {
        sb.AppendLine("    public override async Task<object> DeserializeAsync(global::Neo4j.Driver.IEntity entity)");
        sb.AppendLine("    {");

        var constructors = type.Constructors.Where(c => !c.IsStatic).ToList();
        var parameterlessConstructor = constructors.FirstOrDefault(c => c.Parameters.Length == 0);

        if (parameterlessConstructor != null)
        {
            sb.AppendLine($"        var result = new {type.ToDisplayString()}();");
            GeneratePropertySetters(sb, type, "result", "entity");
        }
        else if (constructors.Any())
        {
            var constructor = constructors.OrderBy(c => c.Parameters.Length).First();
            GenerateConstructorDeserialization(sb, type, constructor);
        }
        else
        {
            sb.AppendLine($"        throw new InvalidOperationException(\"No suitable constructor found for type {type.Name}\");");
        }

        sb.AppendLine("        return result;");
        sb.AppendLine("    }");
    }

    private static void GenerateSerializeMethod(StringBuilder sb, INamedTypeSymbol type)
    {
        sb.AppendLine($"    public override Dictionary<string, object?> Serialize(object obj)");
        sb.AppendLine("    {");
        sb.AppendLine($"        var entity = ({type.ToDisplayString()})obj;");
        sb.AppendLine("        var properties = new Dictionary<string, object?>();");
        sb.AppendLine();

        var properties = type.GetMembers()
            .OfType<IPropertySymbol>()
            .Where(p => !p.IsStatic && p.DeclaredAccessibility == Accessibility.Public && p.GetMethod != null);

        foreach (var property in properties)
        {
            if (IsSimpleType(property.Type))
            {
                var propertyName = GetPropertyName(property);
                sb.AppendLine($"        properties[\"{propertyName}\"] = ConvertToNeo4jValue(entity.{property.Name});");
            }
        }

        sb.AppendLine("        return properties;");
        sb.AppendLine("    }");
    }

    private static void GeneratePropertySetters(StringBuilder sb, INamedTypeSymbol type, string variableName, string entityVar)
    {
        var properties = type.GetMembers()
            .OfType<IPropertySymbol>()
            .Where(p => !p.IsStatic && p.DeclaredAccessibility == Accessibility.Public && !p.IsReadOnly);

        foreach (var property in properties)
        {
            var propertyName = GetPropertyName(property);
            var typeName = property.Type.ToDisplayString();

            sb.AppendLine($"        if (TryGetProperty({entityVar}, \"{propertyName}\", out var {property.Name.ToLower()}Value))");
            sb.AppendLine("        {");

            if (property.Type.NullableAnnotation == NullableAnnotation.Annotated)
            {
                sb.AppendLine($"            {variableName}.{property.Name} = {property.Name.ToLower()}Value == null ? null : ({typeName})ConvertFromNeo4jValue({property.Name.ToLower()}Value, typeof({property.Type.WithNullableAnnotation(NullableAnnotation.None).ToDisplayString()}));");
            }
            else
            {
                sb.AppendLine($"            {variableName}.{property.Name} = ({typeName})ConvertFromNeo4jValue({property.Name.ToLower()}Value, typeof({typeName}))!;");
            }

            sb.AppendLine("        }");
        }
    }

    private static void GenerateConstructorDeserialization(StringBuilder sb, INamedTypeSymbol type, IMethodSymbol constructor)
    {
        // Extract values for constructor parameters
        foreach (var param in constructor.Parameters)
        {
            var propertyName = GetPropertyNameFromParameter(param);
            var paramType = param.Type.ToDisplayString();

            sb.AppendLine($"        var {param.Name} = default({paramType});");
            sb.AppendLine($"        if (TryGetProperty(entity, \"{propertyName}\", out var {param.Name}Value))");
            sb.AppendLine("        {");

            if (param.Type.NullableAnnotation == NullableAnnotation.Annotated)
            {
                sb.AppendLine($"            {param.Name} = {param.Name}Value == null ? null : ({paramType})ConvertFromNeo4jValue({param.Name}Value, typeof({param.Type.WithNullableAnnotation(NullableAnnotation.None).ToDisplayString()}));");
            }
            else
            {
                sb.AppendLine($"            {param.Name} = ({paramType})ConvertFromNeo4jValue({param.Name}Value, typeof({paramType}))!;");
            }

            sb.AppendLine("        }");
        }

        // Call constructor
        sb.Append($"        var result = new {type.ToDisplayString()}(");
        sb.Append(string.Join(", ", constructor.Parameters.Select(p => p.Name)));
        sb.AppendLine(");");

        // Set remaining properties
        GeneratePropertySetters(sb, type, "result", "entity");
    }

    private static void GenerateRegistrationModule(SourceProductionContext context, ImmutableArray<INamedTypeSymbol?> types)
    {
        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine("using Cvoya.Graph.Model.Neo4j.Serialization;");
        sb.AppendLine();
        sb.AppendLine("[System.Runtime.CompilerServices.ModuleInitializer]");
        sb.AppendLine("internal static class EntitySerializerRegistration");
        sb.AppendLine("{");
        sb.AppendLine("    public static void Initialize()");
        sb.AppendLine("    {");

        foreach (var type in types.Where(t => t is not null))
        {
            var typeName = type!.ToDisplayString();
            var namespaceName = type.ContainingNamespace?.ToDisplayString() ?? "Generated";
            var serializerName = $"{type.Name}Serializer";

            sb.AppendLine($"        EntitySerializerRegistry.Register<{typeName}>(new {namespaceName}.Generated.{serializerName}());");
        }

        sb.AppendLine("    }");
        sb.AppendLine("}");

        context.AddSource("EntitySerializerRegistration.g.cs", sb.ToString());
    }

    private static string GetPropertyName(IPropertySymbol property)
    {
        var propertyAttribute = property.GetAttributes()
            .FirstOrDefault(a => a.AttributeClass?.Name == "PropertyAttribute");

        if (propertyAttribute?.ConstructorArguments.Length > 0)
        {
            return propertyAttribute.ConstructorArguments[0].Value?.ToString() ?? property.Name;
        }

        return property.Name;
    }

    private static string GetPropertyNameFromParameter(IParameterSymbol parameter)
    {
        return char.ToUpper(parameter.Name[0]) + parameter.Name.Substring(1);
    }

    private static bool IsSimpleType(ITypeSymbol type)
    {
        var typeName = type.ToDisplayString();
        return typeName switch
        {
            "string" or "int" or "long" or "double" or "float" or "decimal" or "bool"
            or "System.DateTime" or "System.DateTimeOffset" or "System.Guid"
            or "System.TimeSpan" or "System.DateOnly" or "System.TimeOnly" => true,
            _ => type.TypeKind == TypeKind.Enum
        };
    }
}